# -*- coding: utf-8 -*-
"""Basic Neural Network Pytorch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pZOJKrqbkpzdglT3s-dvODIt53o0q_WK
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

X = torch.tensor([[0.0, 0.0],
                  [0.0, 1.0],
                  [1.0, 0.0],
                  [1.0, 1.0],
                  [2.0, 2.0]], dtype=torch.float32)

y = torch.tensor([[0.0],
                  [0.0],
                  [0.0],
                  [1.0],
                  [1.0]], dtype=torch.float32)



class neural(nn.Module):

  def __init__(self):
    super(neural , self).__init__()

    self.f1 = nn.Linear(2, 4)
    self.f2 = nn.Linear(4 , 1)

  def forward(self, X):
    X = F.relu(self.f1(X))
    X = torch.sigmoid(self.f2(X))
    return X



model = neural()

loss_fn = nn.BCELoss()

optimizer = optim.SGD(model.parameters() , lr=0.1)

epochs = 1000

for epoch in range(epochs):
  optimizer.zero_grad()
  output = model(X).squeeze()
  loss= loss_fn(output , y.squeeze())
  loss.backward()
  optimizer.step()

  if (epoch+1) % 100 == 0 or epoch == 0:
    print(f'Epoch: [{epoch+1}/{epochs}] , Loss: {loss.item():.4f}')



with torch.no_grad():
    predictions = model(X)
    predicted_classes = (predictions > 0.5).float()
    print("Predictions:\n", predicted_classes)
    print("\nActual labels:\n", y)