# -*- coding: utf-8 -*-
"""Data Analytics Financial Stock Market Dataset Generator ( 2025  - 07 - 11) .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kXAYPaPzo18qruCRFUvVOH7gMctyDecH
"""

import pandas as pd
import numpy as np

# Set random seed for reproducibility
np.random.seed(42)

# Number of simulated stock entries
n_samples = 500

# Define sectors
sectors = ['Technology', 'Finance', 'Healthcare', 'Energy', 'Consumer Goods']

# Simulate dataset
data = {
    'stock_id': [f'STK{i:04d}' for i in range(n_samples)],
    'sector': np.random.choice(sectors, size=n_samples),
    'company_age': np.random.randint(1, 100, size=n_samples),
    'employees': np.random.randint(50, 10000, size=n_samples),
    'market_cap': np.random.uniform(100e6, 1e11, size=n_samples),
    'price_to_earnings': np.random.uniform(5, 40, size=n_samples),
    'dividend_yield': np.random.uniform(0, 5, size=n_samples),
    'debt_to_equity': np.random.uniform(0.1, 3.0, size=n_samples),
    'price_volatility': np.random.uniform(0.01, 0.15, size=n_samples),
    'avg_volume': np.random.randint(1e5, 1e7, size=n_samples),
    'revenue_growth': np.random.uniform(-0.2, 0.5, size=n_samples),
    'net_income_margin': np.random.uniform(-0.1, 0.3, size=n_samples),
    'return_on_equity': np.random.uniform(-0.2, 0.4, size=n_samples),
    'asset_turnover': np.random.uniform(0.2, 2.5, size=n_samples),
    'free_cash_flow': np.random.uniform(-1e8, 1e9, size=n_samples),
    'beta': np.random.uniform(0.5, 2.0, size=n_samples),
    'stock_price': np.random.uniform(5, 2000, size=n_samples),
    'eps': np.random.uniform(-5, 25, size=n_samples),
    'institutional_ownership': np.random.uniform(0, 1, size=n_samples),
    'retail_ownership': np.zeros(n_samples),  # placeholder for adjustment
    'analyst_rating': np.random.randint(1, 6, size=n_samples),  # 1 = Sell, 5 = Strong Buy
    'dividend_paid': np.random.choice([0, 1], size=n_samples),
    'is_blue_chip': np.random.choice([0, 1], size=n_samples),
    'high_risk_flag': np.random.choice([0, 1], size=n_samples, p=[0.8, 0.2]),  # for classification
    'expected_return_next_year': np.random.uniform(-0.3, 0.5, size=n_samples),  # for regression
}

# Create DataFrame
df_stock = pd.DataFrame(data)

# Ensure retail + institutional ownership = 1
df_stock['retail_ownership'] = 1 - df_stock['institutional_ownership']

# Save to CSV
df_stock.to_csv('stock_market_simulated.csv', index=False)

# Display first few rows


df = df_stock.copy()

def n_val(df):

  df.drop(columns=['stock_id'] , axis=1)

  print('**'*12 , 'Null Values' , '**'*12)
  for col in df.columns: print(f'{col}: {df[col].isnull().sum()}')
  print('--'*35)

  print('**'*12 , 'Sorted Values with respect to n-unique' , '**'*12)
  for col in df.columns: print(f'{col}: {df[col].sort_values(ascending=False).nunique()}')
  print('--'*35)

  print('**'*12 , 'Maximum Values of each Column' , '**'*12)
  for col in df.columns: print(f'{col}: {df[col].max()}')
  print('--'*35)

  print('**'*12 , 'Minimum Values of each Column' , '**'*12)
  for col in df.columns:print(f'{col}: {df[col].min()}')
  print('--'*35)

n_val(df)

def funct():
  pass

df.head()

if df.info() == True:
  display(df.info())

num_col = [y for y in df.select_dtypes(include=[np.number]).columns]

cat_col = [y for y in df.select_dtypes(include=['object']).columns]

print('**'*12)

for n in num_col : print(f'Numeric Column: ({n})')

print('**'*12)

for c in cat_col : print(f'Categorical Columns: ({c})')

print('**'*10)

print(f'length of numeric columns: {len(num_col)}')
print(f'length of categorical columns: {len(cat_col)}')

from seaborn import (scatterplot, histplot)

scatterplot(data=df , x='high_risk_flag' , y='revenue_growth', color='green')
histplot(data=df , x='revenue_growth' , y='employees', color='green')

from matplotlib.pyplot import *
from seaborn import *

import seaborn as sns , matplotlib.pyplot as plt , numpy as np

org_1 = df.copy()

for col in org_1.columns: np.where(
    org_1[col].isnull().any(),
    print(f'{col}: {org_1[col].isnull().sum()}'),
    None
)

def function():

  df['employees'] = pd.to_numeric(df['employees'], errors='coerce')

  from seaborn import (displot , histplot , distplot , scatterplot , lineplot)

  return (displot(df['employees'] , kde=True , label='employees'))

function()

def function():

  from seaborn import (scatterplot ,boxplot)
  import matplotlib.pyplot as plt

  scatterplot(x='employees', y='revenue_growth', data=org_1)
  plt.plot(org_1['employees'], org_1['revenue_growth'], color='red')  # adds a line

  sns.set_style('whitegrid')

  plt.title('Revenue growth Distribution by Sector')

function()

if df['employees'].dtype == np.number is False:
  df['employees'] = pd.to_numeric(df['employees'] , errrs='coerce')
  print(df['employees'].dtype)

for col in df.columns: print(f'{col}: {df[col].dtype}')

import pandas as pd , numpy as np

from sklearn.model_selection import (train_test_split)

from sklearn.linear_model import (LogisticRegression)

from sklearn.preprocessing import (LabelEncoder , PowerTransformer)

from sklearn.metrics import (classification_report , mean_squared_error)

from sklearn.ensemble import (RandomForestRegressor)

class stockdataloader:
  def __init__(self , df: pd.DataFrame) -> None:

    self.df = df.copy()

  def validate(self):

    assert not self.df.isnull().any().any(), 'Data contains nulls'

    assert 'stock_price' in self.df.columns, 'Missing key financials'

  def summerize(self):

    print(self.df.describe()) #Summary stats of all numeric columns

    print('Sector breakdown:\n',self.df['sector'].value_counts())


class stockfeatureengineer:
  #We now go deeper into finance logic: creating new features that aren’t directly given in the raw dataset, but are critical for analysis.

  def __init__(self, df: pd.DataFrame): #is the constructor — it runs when you create an object.

    self.df = df.copy() #stores this dataset inside the object.

  def engineer_feature(self):

    # High institutional ownership often means more trust by banks, funds, large players.
    # High retail = emotional decisions (risky
    self.df['ownership_score'] = self.df['institutional_ownership'] - self.df['retail_ownership']

    # This gives insight into unjustified price swings.
    # Risk compared to market (beta = 1 = same risk as ma
    self.df['volatility_ratio'] = self.df['price_volatility'] / df['beta']

    # Combines growth rate and profit margin
    # Measures how profitable the company is while growing
    self.df['revenue_efficiency'] = self.df['revenue_growth'] * self.df['net_income_margin']

    return self.df #Returns the new DataFrame with all engineered columns added.

for col in org_1:
  print(f'{col}')

df.groupby('is_blue_chip')[['retail_ownership' ,'price_volatility', 'institutional_ownership']].agg(['sum' , 'mean' , 'count'])

class stockClassifier:
  def __inti__(self,df: pd.DataFrame):
    self.df = df.copy()
    self.model = LogisticRegression()

  def prepare_data(self):
    X = self.df.drop(columns=['high_risk_flag' , 'expected_return_next_year' , 'stock_id'])
    y = self.df['high_risk_flag']

    #label encoder sector

    X['sector'] = LabelEncoder().fit_transform(['sector'])

    return train_test_split(X , y , test_size=0.2 , random_state=42)


  def train(self):
    X_train , X_test, y_train , y_test = self.prepare_data()
    self.model.fit(X_train , y_train)
    preds = self.model.predict(X_test)

    print(f'Classification Report:\n' , classification_report(y_test , preds))

class stockregressor:

  def __init__(self):
    self.df = df.copy()
    self.model = RandomForestRegressor(n_estimators=100 , random_state=42)

  def prepare_data(self):
    X = self.df.drop(columns=['expected_return_next_year' , 'high_risk_flag' ,'stock_id'])
    y = self.df['expected_return_next_year']
    X['sector'] = LabelEncoder().fit_transform(X['sector'])
    X = PowerTransformer().fit_transform(X)

    return train_test_split(X , y , test_size=0.2 , random_state=24)


  def train(self):
    X_train , X_test , y_train , y_test = self.prepare_data()
    self.model.fit(X_train , y_train)
    preds = self.model.predict(X_test)
    print(f'MSE: ', mean_squared_error(y_test , preds))

class stocksdcreener:

  def __init__(self , df):
    self.df = df.copy()

  def screen(self, min_pe=5 , max_pe=20 , min_roe=0.1 , max_de=1.5, blue_chip=True):
    screened = self.df[
        (self.df['price_to_earnings'] >= min_pe) &
        (self.df['price_to_earnings'] <= max_pe) &
        (self.df['return_on_equity'] >= min_roe) &
        (self.df['debt_to_equity'] <= max_de)
    ]

    if blue_chip:
      screened = screened[screened['is_blue_chip'] == 1]
    return screened

class stockadvisor:

  def __init__(self):
    self.df = df.copy()

  def run(self):
    print(f'\n Loading & Validating Data')
    loader = stockdataloader(self.df)
    loader.validate()

